"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webdriverioSchematics = void 0;
const fs = require("fs");
const path = require("path");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const operators_1 = require("rxjs/operators");
const rxjs_1 = require("rxjs");
const config_1 = require("@wdio/cli/build/commands/config");
const constants_1 = require("./constants");
const types_1 = require("./types");
const utils_1 = require("./utils");
// You don't have to export the function as default. You can also have more than one rule factory
// per file.
function webdriverioSchematics(_options) {
    return (tree, _context) => {
        _options = Object.assign(Object.assign({}, _options), { __version__: (0, utils_1.getAngularVersion)(tree) });
        return (0, schematics_1.chain)([
            updateDependencies(_options),
            _options.removeProtractor ? removeFiles() : (0, schematics_1.noop)(),
            !_options.noWizard ? runWizard(_options) : (0, schematics_1.noop)(),
            !_options.noBuilder ? modifyAngularJson(_options) : (0, schematics_1.noop)(),
        ])(tree, _context);
    };
}
exports.webdriverioSchematics = webdriverioSchematics;
function updateDependencies(options) {
    let removeDependencies;
    return (tree, context) => {
        context.logger.debug('Updating dependencies...');
        context.addTask(new tasks_1.NodePackageInstallTask());
        if (options.removeProtractor) {
            removeDependencies = (0, rxjs_1.of)('protractor').pipe((0, operators_1.map)((packageName) => {
                context.logger.debug(`Removing ${packageName} dependency`);
                (0, utils_1.removePackageJsonDependency)(tree, {
                    type: types_1.NodeDependencyType.Dev,
                    name: packageName,
                });
                return tree;
            }));
        }
        const addDependencies = (0, rxjs_1.of)('@wdio/cli').pipe((0, operators_1.concatMap)((packageName) => (0, utils_1.getLatestNodeVersion)(packageName)), (0, operators_1.map)((packageFromRegistry) => {
            const { name, version } = packageFromRegistry;
            context.logger.debug(`Adding ${name}:${version} to ${types_1.NodeDependencyType.Dev}`);
            (0, utils_1.addPackageJsonDependency)(tree, {
                type: types_1.NodeDependencyType.Dev,
                name,
                version,
            });
            return tree;
        }));
        if (options.removeProtractor) {
            return (0, rxjs_1.concat)(removeDependencies, addDependencies);
        }
        return (0, rxjs_1.concat)(addDependencies);
    };
}
function removeFiles() {
    return (tree, context) => {
        if (!tree.exists('./angular.json')) {
            return tree;
        }
        const angularJsonValue = (0, utils_1.getAngularJsonValue)(tree);
        const { projects } = angularJsonValue;
        // clean up projects generated by cli with versions <= 7
        Object.keys(projects)
            .filter((name) => name.endsWith('-e2e'))
            .forEach((projectName) => {
            const projectRoot = projects[projectName].root;
            (0, utils_1.deleteDirectory)(tree, projectRoot);
            context.logger.debug(`Removing ${projectName} from angular.json projects`);
            delete angularJsonValue.projects[projectName];
        });
        // clean up projects generated by cli with versions > 7
        Object.keys(projects)
            .filter((name) => !name.endsWith('-e2e'))
            .forEach((projectName) => {
            const projectRoot = projects[projectName].root;
            (0, utils_1.deleteDirectory)(tree, `${projectRoot}/e2e`);
        });
        return tree.overwrite('./angular.json', JSON.stringify(angularJsonValue, null, 2));
    };
}
function runWizard(_options) {
    return (tree, context) => ((0, rxjs_1.concat)((0, config_1.handler)(_options)).pipe((0, operators_1.switchMap)(({ installedPackages = [], parsedAnswers }) => (0, rxjs_1.from)(Promise.all(installedPackages.map((packageName) => (0, utils_1.getLatestNodeVersion)(packageName)))).pipe((0, operators_1.map)(updateFiles(tree, context, parsedAnswers))))));
}
function updateFiles(tree, context, parsedAnswers) {
    return (packagesFromRegistry) => {
        for (let packageFromRegistry of packagesFromRegistry) {
            const { name, version } = packageFromRegistry;
            context.logger.debug(`Adding ${name}:${version} to ${types_1.NodeDependencyType.Dev}`);
            (0, utils_1.addPackageJsonDependency)(tree, {
                type: types_1.NodeDependencyType.Dev,
                name,
                version,
            });
        }
        constants_1.TS_CONFIG.compilerOptions.types.push(...packagesFromRegistry
            .map((pkg) => pkg.name)
            .filter((pkg) => pkg.startsWith('@wdio')));
        const relative = path.relative(process.cwd(), parsedAnswers.destSpecRootPath);
        const tsconfigDir = relative.split(path.sep)[0];
        fs.writeFileSync(path.join(process.cwd(), tsconfigDir, 'tsconfig.e2e.json'), JSON.stringify(constants_1.TS_CONFIG, null, 4));
        const wdioConfigPath = path.join(process.cwd(), `wdio.conf.${parsedAnswers.isUsingTypeScript ? 'ts' : 'js'}`);
        const wdioConfig = fs.readFileSync(wdioConfigPath).toString();
        fs.writeFileSync(wdioConfigPath, (wdioConfig.slice(0, -4) + '\n' +
            '    autoCompileOpts: {\n' +
            '        tsNodeOpts: {\n' +
            '            transpileOnly: true,\n' +
            '            project: __dirname + \'/' + tsconfigDir + '/tsconfig.e2e.json\'\n' +
            '        }\n' +
            '    }\n' +
            '}\n'));
        return tree;
    };
}
function modifyAngularJson(options) {
    return (tree, context) => {
        if (!tree.exists('./angular.json')) {
            throw new schematics_1.SchematicsException('angular.json not found');
        }
        const angularJsonVal = (0, utils_1.getAngularJsonValue)(tree);
        const { projects } = angularJsonVal;
        if (!projects) {
            throw new schematics_1.SchematicsException('projects in angular.json is not defined');
        }
        Object.keys(projects).forEach((project) => {
            const wdioConf = {
                builder: '@wdio/schematics:wdio',
                options: {
                    devServerTarget: `${project}:serve`,
                },
                configurations: {
                    production: {
                        devServerTarget: `${project}:serve:production`,
                    }
                }
            };
            const configFile = !!projects[project].root
                ? `${projects[project].root}/wdio.conf.js`
                : null;
            if (configFile) {
                Object.assign(wdioConf.options, { configFile });
            }
            if (options.removeProtractor) {
                context.logger.debug(`Replacing e2e command with wdio-run in angular.json`);
                (0, utils_1.removeE2ELinting)(tree, angularJsonVal, project);
            }
            context.logger.debug(`Adding webdriverio/tsconfig.json to angular.json-tslint config`);
            (0, utils_1.addWDIOTsConfig)(tree, angularJsonVal, project);
            context.logger.debug(`Adding wdio-run command in angular.json`);
            const projectArchitectJson = angularJsonVal['projects'][project]['architect'];
            projectArchitectJson['wdio-run'] = wdioConf;
            if (options.removeProtractor) {
                projectArchitectJson['e2e'] = wdioConf;
            }
            return tree.overwrite('./angular.json', JSON.stringify(angularJsonVal, null, 2));
        });
        return tree;
    };
}
//# sourceMappingURL=index.js.map